## (五) 集合处理 
1. 【强制】关于`hashCode`和`equals`的处理，遵循如下规则： 
<br>1） 只要重写`equals`，就必须重写`hashCode`。 
<br>2） 因为Set存储的是不重复的对象，依据`hashCode`和`equals`进行判断，所以Set存储的对象必须重写这两个方法。 
<br>3） 如果自定义对象作为Map的键，那么必须重写`hashCode`和`equals`。 
<br><span style="color:orange">说明</span>：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。 
2. 【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList. 
<br><span style="color:orange">说明</span>：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。 
3. 【强制】在subList场景中，**高度注意**对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常。 
4. 【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是`list.size()`。 
<br><span style="color:orange">说明</span>：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 
<br><span style="color:green">正例</span>： 
```
  List<String> list = new ArrayList<String>(2);      
  list.add("guan");     
  list.add("bao");       
  String[] array = new String[list.size()];      
  array = list.toArray(array);
```
<span style="color:red">反例</span>：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。
5. 【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。 
<br><span style="color:orange">说明</span>：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。
```
String[] str = new String[] { "you", "wu" };     
List list = Arrays.asList(str); 
```
第一种情况：list.add("yangguanbao"); 运行时异常。
<br>第二种情况：str[0] = "gujin"; 那么list.get(0)也会随之修改。
6. 【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。 
<br><span style="color:green">正例</span>： 
```
    Iterator<String> iterator = list.iterator();  while (iterator.hasNext()) {          
          String item = iterator.next();                  
                if (删除元素的条件) {                   
                        iterator.remove();                 
                }      
    }
```
<span style="color:red">反例</span>：
 ```
    List<String> list = new ArrayList<String>();      
    list.add("1");      
    list.add("2");      
    for (String item : list) {        
        if ("1".equals(item)) {          
              list.remove(item);         
          }   
    }
```
<span style="color:orange">说明</span>：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？
7. 【强制】 在JDK7版本及以上，`Comparator`要满足如下三个条件，不然`Arrays.sort`，`Collections.sort`会报IllegalArgumentException异常。
<br><span style="color:orange">说明</span>：三个条件如下：
<br>1） x，y的比较结果和y，x的比较结果相反。
<br>2） x>y，y>z，则x>z。 
<br>3） x=y，则x，z比较结果和y，z比较结果相同。 
<br><span style="color:red">反例</span>：下例中没有处理相等的情况，实际使用中可能会出现异常：
```
    new Comparator<Student>() {           
          @Override          
          public int compare(Student o1, Student o2) {              
            return o1.getId() > o2.getId() ? 1 : -1;       
          }  
    };  
```
8. 【推荐】高度注意Map类集合K/V能不能存储null值的情况，如下表格：

		| 集合类             | Key          | Value        | Super       | 说明                   |
        |-------------------|--------------|--------------|-------------|------------------------|
        | Hashtable         | 不允许为null | 不允许为null | Dictionary  | 线程安全               |
        | ConcurrentHashMap | 不允许为null | 不允许为null | AbstractMap | 锁分段技术（JDK8:CAS）  |
        | TreeMap           | 不允许为null | 允许为null   | AbstractMap | 线程不安全             |
        | HashMap           | 允许为null   | 允许为null   | AbstractMap | 线程不安全             |

    <span style="color:red">反例</span>： 由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，而事实上，存储null值时会抛出NPE异常。